diff --git a/phase2-cli/src/combine.rs b/phase2-cli/src/combine.rs
index 8cde0fb..6406ad6 100644
--- a/phase2-cli/src/combine.rs
+++ b/phase2-cli/src/combine.rs
@@ -8,7 +8,7 @@ use std::io::{BufRead, BufReader};
 use tracing::info;
 
 const INITIAL_IS_COMPRESSED: UseCompression = UseCompression::No;
-const CONTRIBUTION_IS_COMPRESSED: UseCompression = UseCompression::Yes;
+const CONTRIBUTION_IS_COMPRESSED: UseCompression = UseCompression::No;
 const COMBINED_IS_COMPRESSED: UseCompression = UseCompression::No;
 
 pub fn combine(
@@ -26,7 +26,7 @@ pub fn combine(
     let full_parameters = MPCParameters::<BW6_761>::read_fast(
         full_contents.as_slice(),
         INITIAL_IS_COMPRESSED,
-        CheckForCorrectness::No,
+        CheckForCorrectness::Full,
         false,
         SubgroupCheckMode::Auto,
     )
@@ -37,20 +37,22 @@ pub fn combine(
     let query_parameters = MPCParameters::<BW6_761>::read_groth16_fast(
         &mut query_contents,
         INITIAL_IS_COMPRESSED,
-        CheckForCorrectness::No,
+        CheckForCorrectness::Full,
         false,
         SubgroupCheckMode::Auto,
     )
     .expect("should have deserialized initial query params");
 
     let mut all_parameters = vec![];
+    let mut i = 0;
     for line in response_list_reader.lines() {
         let line = line.expect("should have read line");
         let contents = std::fs::read(line).expect("should have read response");
+        i += 1;
         let parameters = MPCParameters::<BW6_761>::read_fast(
             contents.as_slice(),
             CONTRIBUTION_IS_COMPRESSED,
-            CheckForCorrectness::No,
+            CheckForCorrectness::Full,
             false,
             SubgroupCheckMode::Auto,
         )
diff --git a/phase2-cli/src/contribute.rs b/phase2-cli/src/contribute.rs
index 98ff8d4..7b33ba8 100644
--- a/phase2-cli/src/contribute.rs
+++ b/phase2-cli/src/contribute.rs
@@ -8,7 +8,7 @@ use std::io::Write;
 use tracing::info;
 
 const COMPRESSED_INPUT: UseCompression = UseCompression::No;
-const COMPRESSED_OUTPUT: UseCompression = UseCompression::Yes;
+const COMPRESSED_OUTPUT: UseCompression = UseCompression::No;
 
 pub fn contribute(
     challenge_filename: &str,
diff --git a/phase2-cli/src/new_challenge.rs b/phase2-cli/src/new_challenge.rs
index 483f829..e774afa 100644
--- a/phase2-cli/src/new_challenge.rs
+++ b/phase2-cli/src/new_challenge.rs
@@ -51,7 +51,7 @@ pub fn new_challenge(
             c,
             &mut phase1_readable_map,
             UseCompression::No,
-            CheckForCorrectness::No,
+            CheckForCorrectness::Full,
             1 << phase1_powers,
             phase2_size,
             chunk_size,
diff --git a/phase2-cli/src/verify.rs b/phase2-cli/src/verify.rs
index f36e1de..b4bd35d 100644
--- a/phase2-cli/src/verify.rs
+++ b/phase2-cli/src/verify.rs
@@ -7,7 +7,7 @@ use std::io::Write;
 use tracing::info;
 
 const PREVIOUS_CHALLENGE_IS_COMPRESSED: UseCompression = UseCompression::No;
-const CONTRIBUTION_IS_COMPRESSED: UseCompression = UseCompression::Yes;
+const CONTRIBUTION_IS_COMPRESSED: UseCompression = UseCompression::No;
 
 pub fn verify(
     challenge_filename: &str,
diff --git a/phase2/src/parameters.rs b/phase2/src/parameters.rs
index 9cb150f..9001313 100644
--- a/phase2/src/parameters.rs
+++ b/phase2/src/parameters.rs
@@ -556,27 +556,33 @@ impl<E: PairingEngine> MPCParameters<E> {
         subgroup_check_mode: SubgroupCheckMode,
     ) -> Result<Parameters<E>> {
         // vk
+        //println!("Entering read_groth16_fast");
         let alpha_g1: E::G1Affine = reader.read_element(compressed, check_correctness)?;
+        //println!("1");
         let beta_g2: E::G2Affine = reader.read_element(compressed, check_correctness)?;
+        //println!("2");
         let gamma_g2: E::G2Affine = reader.read_element(compressed, check_correctness)?;
+        //println!("3");
         let delta_g2: E::G2Affine = reader.read_element(compressed, check_correctness)?;
+        // println!("4");
         let gamma_abc_g1: Vec<E::G1Affine> = read_vec(&mut reader, compressed, check_correctness)?;
+        //println!("5");
 
         // rest of the parameters
         let beta_g1: E::G1Affine = reader.read_element(compressed, check_correctness)?;
+        //println!("6");
         let delta_g1: E::G1Affine = reader.read_element(compressed, check_correctness)?;
-
-        // a,b queries guaranteed to have infinity points for variables unused in left,right r1cs
-        // inputs respectively
-        let ab_query_correctness = match check_correctness {
-            CheckForCorrectness::Full => CheckForCorrectness::OnlyInGroup,
-            _ => check_correctness,
-        };
-        let a_query: Vec<E::G1Affine> = read_vec(&mut reader, compressed, ab_query_correctness)?;
-        let b_g1_query: Vec<E::G1Affine> = read_vec(&mut reader, compressed, ab_query_correctness)?;
-        let b_g2_query: Vec<E::G2Affine> = read_vec(&mut reader, compressed, ab_query_correctness)?;
+        //println!("7");
+        let a_query: Vec<E::G1Affine> = read_vec(&mut reader, compressed, CheckForCorrectness::No)?;
+        //println!("8");
+        let b_g1_query: Vec<E::G1Affine> = read_vec(&mut reader, compressed, CheckForCorrectness::No)?;
+        //println!("9");
+        let b_g2_query: Vec<E::G2Affine> = read_vec(&mut reader, compressed, CheckForCorrectness::No)?;
+        //println!("10");
         let h_query: Vec<E::G1Affine> = read_vec(&mut reader, compressed, check_correctness)?;
+        //println!("11");
         let l_query: Vec<E::G1Affine> = read_vec(&mut reader, compressed, check_correctness)?;
+        //println!("12");
 
         let params = Parameters::<E> {
             vk: VerifyingKey::<E> {
diff --git a/phase2/src/polynomial.rs b/phase2/src/polynomial.rs
index 93deddf..5b525e4 100644
--- a/phase2/src/polynomial.rs
+++ b/phase2/src/polynomial.rs
@@ -27,6 +27,8 @@ pub fn eval<E: PairingEngine>(
     Vec<E::G1Affine>,
 ) {
     // calculate the evaluated polynomials
+    //println!("Printing coeffs_g1 in eval: {:?}", coeffs_g1);
+    //println!("Printing at in eval: {:?}", at);
     let a_g1 = dot_product_vec(at, coeffs_g1);
     let b_g1 = dot_product_vec(bt, coeffs_g1);
     let b_g2 = dot_product_vec(bt, coeffs_g2);
@@ -42,6 +44,8 @@ pub fn eval<E: PairingEngine>(
     let gamma_abc_g1 = gamma_abc_g1.iter().map(|p| p.into_affine()).collect();
     let l = l.iter().map(|p| p.into_affine()).collect();
 
+    //    println!("About to return a_g1 from eval: {:?}", a_g1);
+    //println!("About to return gamma_abc_g1 from eval: {:?}", gamma_abc_g1);
     (a_g1, b_g1, b_g2, gamma_abc_g1, l)
 }
 
@@ -68,6 +72,7 @@ fn dot_product_ext<E: PairingEngine>(
 /// This is a NxN * Nx1 -> Nx1 matrix multiplication basically
 fn dot_product_vec<C: AffineCurve>(input: &[Vec<(C::ScalarField, usize)>], coeffs: &[C]) -> Vec<C::Projective> {
     let mut ret = input.par_iter().map(|row| dot_product(row, coeffs)).collect::<Vec<_>>();
+    //println!("Printing ret in dot_product_vec: {:?}", ret);
     // Batch normalize
     C::Projective::batch_normalization(&mut ret);
     ret
@@ -78,16 +83,16 @@ fn dot_product_vec<C: AffineCurve>(input: &[Vec<(C::ScalarField, usize)>], coeff
 /// `coeffs` vector offset by `num_inputs`
 #[allow(clippy::redundant_closure)]
 fn dot_product<C: AffineCurve>(input: &[(C::ScalarField, usize)], coeffs: &[C]) -> C::Projective {
-    input
-        .into_par_iter()
-        .fold(
-            || C::Projective::zero(),
-            |mut sum, &(coeff, ind)| {
-                sum += &coeffs[ind].mul(coeff);
-                sum
-            },
-        )
-        .sum()
+    //println!("Input for dot product is: {:?}", input);
+    let result = input.into_par_iter().fold(
+        || C::Projective::zero(),
+        |mut sum, &(coeff, ind)| {
+            sum += &coeffs[ind].mul(coeff);
+            sum
+        },
+    );
+    //println!("Dot product before sum: {:?}", result);
+    result.sum()
 }
 
 #[cfg(test)]
diff --git a/setup-utils/src/groth16_utils.rs b/setup-utils/src/groth16_utils.rs
index 6a44105..b408690 100644
--- a/setup-utils/src/groth16_utils.rs
+++ b/setup-utils/src/groth16_utils.rs
@@ -171,18 +171,27 @@ impl<E: PairingEngine> Groth16Params<E> {
         let span = info_span!("Groth16Utils_read");
         let _enter = span.enter();
 
+        //println!("About to read elements");
         let mut reader = std::io::Cursor::new(reader);
+        // println!("1");
         let alpha_g1 = reader.read_element(compressed, check_input_for_correctness)?;
+        //println!("2");
         let beta_g1 = reader.read_element(compressed, check_input_for_correctness)?;
+        //println!("3");
         let beta_g2 = reader.read_element(compressed, check_input_for_correctness)?;
+        //println!("Read elements");
 
         let position = reader.position() as usize;
+        //println!("4");
         let reader = &mut &reader.get_mut()[position..];
 
+        //println!("About to split transcript");
         // Split the transcript in the appropriate sections
         let (in_coeffs_g1, in_coeffs_g2, in_alpha_coeffs_g1, in_beta_coeffs_g1, in_h_g1) =
             split_transcript::<E>(reader, phase1_size, num_constraints, compressed);
+        //println!("Split transcript");
 
+        //println!("About to read parameters");
         info!("reading groth16 parameters...");
         // Read all elements in parallel
         // note: '??' is used for getting the result from the threaded operation,
@@ -237,25 +246,31 @@ fn split_transcript<E: PairingEngine>(
     size: usize,
     compressed: UseCompression,
 ) -> SplitBuf {
+    //println!("a");
     let g1_size = buffer_size::<E::G1Affine>(compressed);
+    //println!("b");
     let g2_size = buffer_size::<E::G2Affine>(compressed);
-
+    //println!("c");
     // N elements per coefficient
     let (coeffs_g1, others) = input.split_at(g1_size * size);
+    //println!("d");
     let (_, others) = others.split_at((phase1_size - size) * g1_size);
-
+    //println!("e");
     let (coeffs_g2, others) = others.split_at(g2_size * size);
+    //println!("f");
     let (_, others) = others.split_at((phase1_size - size) * g2_size);
-
+    //println!("g");
     let (alpha_coeffs_g1, others) = others.split_at(g1_size * size);
+    //println!("h");
     let (_, others) = others.split_at((phase1_size - size) * g1_size);
-
+    //println!("i");
     let (beta_coeffs_g1, others) = others.split_at(g1_size * size);
+    //println!("j");
     let (_, others) = others.split_at((phase1_size - size) * g1_size);
-
+    //println!("k");
     // N-1 for the h coeffs
     let (h_coeffs, _) = others.split_at(g1_size * (size - 1));
-
+    //println!("l");
     (coeffs_g1, coeffs_g2, alpha_coeffs_g1, beta_coeffs_g1, h_coeffs)
 }
 
diff --git a/setup-utils/src/io/read.rs b/setup-utils/src/io/read.rs
index 58d2bdf..5532e73 100644
--- a/setup-utils/src/io/read.rs
+++ b/setup-utils/src/io/read.rs
@@ -76,6 +76,7 @@ impl<R: Read> Deserializer for R {
             return Err(Error::PointAtInfinity);
         }
 
+        //println!("Read element");
         Ok(point)
     }
 
